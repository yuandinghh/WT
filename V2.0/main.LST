C51 COMPILER V9.01   MAIN                                                                  11/30/2019 02:05:49 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: F:\mdk4\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //2019-11-27 8051‘Ï¬÷◊”  ‘¨∂°
   2          #include "lcd.h"
   3          #include <reg51.h>                       //¥ÀŒƒº˛÷–∂®“Â¡Àµ•∆¨ª˙µƒ“ª–©Ãÿ ‚π¶ƒ‹ºƒ¥Ê∆˜
   4          #include "RF2401.h"     
   5          #include "ds1302.h"
   6          #include <intrins.h>
   7          #include "temp.h"
   8          #include <string.h>
   9          //#include <stdlib.h>      #include <stdio.h>
  10            
  11          uchar CNCHAR[6] = "…„ œ∂»";
  12          //void LcdDisplaytemp(int);
  13          //void UsartConfiguration();
  14          //typedef unsigned int u16;
  15          uchar  sta,i;    //  ◊¥Ã¨±‰¡ø
  16          #define RX_DR  (sta & 0x40)  // Ω” ’≥…π¶÷–∂œ±Í÷æ
  17          #define TX_DS  (sta & 0x20)  // ∑¢…‰≥…π¶÷–∂œ±Í÷æ
  18          #define MAX_RT (sta & 0x10)  // ÷ÿ∑¢“Á≥ˆ÷–∂œ±Í÷æ
  19          #define sbuflen  50   //¥Æ––Ω” ‹≥§∂»
  20          #define   delayus(int)  _delay_us(int)
  21          #define  delayms(int)     _delay_ms(int)
  22          bit sbufoverflow = 0 ;    //keil∂®“ÂŒª±‰¡ø
  23          u8  sbufc=0;
  24          unsigned char idata sbuf[sbuflen];        //∂®“Â‘⁄idata 
  25           static char  idata  itoap[7];      //±ÿ–ÎŒ™static±‰¡ø£¨ªÚ’ﬂ «»´æ÷±‰¡ø
  26          
  27          unsigned char SetState,SetPlace;
  28          sbit CE=P1^0;
  29          sbit IRQ=P3^3;
  30          sbit CSN=P3^7;
  31          sbit MOSI=P2^2;
  32          sbit MISO=P2^0;
  33          sbit SCK=P3^6;
  34          sbit led=P2^0;  sbit LED=P2^0;       //sbit LED=P0^0;
  35          sbit led1=P2^1; sbit led2=P2^2;  sbit led3=P2^3;  sbit led4=P2^4;  sbit led5=P2^4;  sbit led6=P2^6;
  36          sbit k1 = P3^1 ;    sbit  k2=  P3^0; sbit  k3 = P3^2; sbit  k4 = P3^3;  //key
  37          uchar code TX_Addr[]={0x34,0x43,0x10,0x10,0x01};
  38          uchar code TX_Buffer[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  39          uchar RX_Buffer[RX_DATA_WITDH];
  40          
  41          unsigned char SetState,SetPlace;
  42          //void Delay10ms(void);   //ŒÛ≤Ó 0us
  43                  
  44          void _delay_us(uint x)     {             //—” ± ƒ…√Î
  45   1       uint i,j;
  46   1       for (j=0;j<x;j++)
  47   1        for (i=0;i<12;i++);
  48   1      }
  49          void _delay_ms(uint x)
  50          {
  51   1       uint i,j;
  52   1       for (j=0;j<x;j++)
  53   1        for (i=0;i<120;i++);
  54   1      }
  55          
C51 COMPILER V9.01   MAIN                                                                  11/30/2019 02:05:49 PAGE 2   

  56          void sbufsend(uchar c) {         //¥Æ––ø⁄∑¢ÀÕ“ª∏ˆ◊÷∑˚
  57   1              SBUF=c;                         //Ω´Ω” ’µΩµƒ ˝æ›∑≈»ÎµΩ∑¢ÀÕºƒ¥Ê∆˜
  58   1              while(!TI);                                              //µ»¥˝∑¢ÀÕ ˝æ›ÕÍ≥…
  59   1              TI=0;    _delay_ms(10)  ;
  60   1      }
  61          void sbufsendstr(char str[]) {  //∑¢ÀÕ◊÷∑˚¥Æ
  62   1              uchar len,i;   len = strlen(str);
  63   1              for(i=0;i<len;i++) sbufsend(str[i]);  }
  64          
  65          void LcdDisplaytemp(int temp) {  //lcdœ‘ æ       Œ¬∂»÷µ   LCDœ‘ æ∂¡»°µΩµƒŒ¬∂»     ‰»Î   : v  Œ¬∂»÷µ
  66   1        unsigned char  datas[] = {0, 0, 0, 0, 0}; //∂®“Â ˝◊È
  67   1        float tp;  
  68   1              if(temp< 0)                             //µ±Œ¬∂»÷µŒ™∏∫ ˝
  69   1              {
  70   2                      LcdWriteCom(0x80);              //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
  71   2      //              SBUF='-';       while(!TI);     TI=0;   //Ω´Ω” ’µΩµƒ ˝æ›∑≈»ÎµΩ∑¢ÀÕºƒ¥Ê∆˜
  72   2                  LcdWriteData('-');                  //œ‘ æ∏∫
  73   2                      //“ÚŒ™∂¡»°µƒŒ¬∂» « µº Œ¬∂»µƒ≤π¬Î£¨À˘“‘ºı1£¨‘Ÿ»°∑¥«Û≥ˆ‘≠¬Î
  74   2                      temp=temp-1;            temp=~temp;                     tp=temp;
  75   2                      temp=tp*0.0625*100+0.5; //¡Ù¡Ω∏ˆ–° ˝µ„æÕ*100£¨+0.5 «Àƒ…·ŒÂ»Î£¨“ÚŒ™C”Ô—‘∏°µ„ ˝◊™ªªŒ™’˚–Õµƒ ±∫Ú∞—–° ˝µ„
  76   2      //∫Û√Êµƒ ˝◊‘∂Ø»•µÙ£¨≤ªπ‹ «∑Ò¥Û”⁄0.5£¨∂¯+0.5÷Æ∫Û¥Û”⁄0.5µƒæÕ «Ω¯1¡À£¨–°”⁄0.5µƒæÕÀ„”…?0.5£¨ªπ «‘⁄–° ˝µ„∫Û√Ê°£
  77   2              }
  78   1              else    {                       
  79   2                      LcdWriteCom(0x80);              //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
  80   2                  LcdWriteData('+');          //œ‘ æ’˝
  81   2      //              SBUF='+';                       while(!TI);                     TI=0;            //«Â≥˝∑¢ÀÕÕÍ≥…±Í÷æŒª
  82   2                      tp=temp;//“ÚŒ™ ˝æ›¥¶¿Ì”––° ˝µ„À˘“‘Ω´Œ¬∂»∏≥∏¯“ª∏ˆ∏°µ„–Õ±‰¡ø»Áπ˚Œ¬∂» «’˝µƒƒ«√¥£¨ƒ«√¥’˝ ˝µƒ‘≠¬ÎæÕ «≤π¬ÎÀ¸±æ
             -…Ì
  83   2                      temp=tp*0.0625*100+0.5; //¡Ù¡Ω∏ˆ–° ˝µ„æÕ*100£¨+0.5 «Àƒ…·ŒÂ»Î£¨“ÚŒ™C”Ô—‘∏°µ„ ˝◊™ªªŒ™’˚–Õµƒ ±∫Ú∞—–° ˝µ„
  84   2              }
  85   1              datas[0] = temp / 10000;        datas[1] = temp % 10000 / 1000;
  86   1              datas[2] = temp % 1000 / 100;   datas[3] = temp % 100 / 10;             datas[4] = temp % 10;
  87   1      
  88   1              LcdWriteCom(0x82);                //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
  89   1              LcdWriteData('0'+datas[0]); //∞ŸŒª 
  90   1      //      SBUF = '0'+datas[0];while (!TI);        TI = 0;                 //Ω´Ω” ’µΩµƒ ˝æ›∑≈»ÎµΩ∑¢ÀÕºƒ¥Ê∆˜
  91   1              LcdWriteCom(0x83);               //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
  92   1              LcdWriteData('0'+datas[1]); // ÆŒª
  93   1      //      SBUF = '0'+datas[1];            while (!TI);    TI = 0;
  94   1              LcdWriteCom(0x84);              //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
  95   1              LcdWriteData('0'+datas[2]); //∏ˆŒª 
  96   1      //      SBUF = '0'+datas[2];    while (!TI);  TI = 0;
  97   1              LcdWriteCom(0x85);              //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
  98   1              LcdWriteData('.');              //œ‘ æ °Æ.°Ø            SBUF = '.';     while (!TI); TI = 0;
  99   1              LcdWriteCom(0x86);               //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
 100   1              LcdWriteData('0'+datas[3]); //œ‘ æ–° ˝µ„        SBUF = '0'+datas[3];    while (!TI);    TI = 0;
 101   1              LcdWriteCom(0x87);               //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
 102   1              LcdWriteData('0'+datas[4]); //œ‘ æ–° ˝µ„        SBUF = '0'+datas[4];//Ω´Ω” ’µΩµƒ ˝æ›∑≈»ÎµΩ∑¢ÀÕºƒ¥Ê∆˜    while (
             -!-TI);          TI = 0;   
 103   1      //      for(i=0; i<6; i++)              {               SBUF = CNCHAR[i];               while (!TI);            TI = 0;         }
 104   1      }
 105          void nRF24L01_Init(void)           //nRF24L01≥ı ºªØ
 106          {
 107   1       CE=0;//¥˝ª˙ƒ£ Ω¢Ò
 108   1       CSN=1;   SCK=0; IRQ=1;   }
 109          uchar SPI_RW(uchar byte)   //SPI ±–Ú∫Ø ˝
 110          {
 111   1       uchar i;
 112   1       for(i=0;i<8;i++)//“ª◊÷Ω⁄8Œª—≠ª∑8¥Œ–¥»Î
 113   1       {
 114   2        if(byte&0x80)//»Áπ˚ ˝æ›◊Ó∏ﬂŒª «1
 115   2         MOSI=1;//œÚNRF24L01–¥1
C51 COMPILER V9.01   MAIN                                                                  11/30/2019 02:05:49 PAGE 3   

 116   2        else //∑Ò‘Ú–¥0
 117   2         MOSI=0;
 118   2        byte<<=1;//µÕ“ªŒª“∆µΩ◊Ó∏ﬂŒª
 119   2        SCK=1;//SCK¿≠∏ﬂ£¨–¥»Î“ªŒª ˝æ›£¨Õ¨ ±∂¡»°“ªŒª ˝æ›
 120   2        if(MISO)
 121   2         byte|=0x01;
 122   2        SCK=0;//SCK¿≠µÕ
 123   2       }
 124   1       return byte;//∑µªÿ∂¡»°“ª◊÷Ω⁄
 125   1      }
 126          //SPI–¥ºƒ¥Ê∆˜“ª◊÷Ω⁄∫Ø ˝
 127          //reg:ºƒ¥Ê∆˜µÿ÷∑
 128          //value:“ª◊÷Ω⁄£®÷µ£©
 129          uchar SPI_W_Reg(uchar reg,uchar value)
 130          {
 131   1       uchar status;//∑µªÿ◊¥Ã¨
 132   1       CSN=0;//SPI∆¨—°
 133   1       status=SPI_RW(reg);//–¥»Îºƒ¥Ê∆˜µÿ÷∑£¨Õ¨ ±∂¡»°◊¥Ã¨
 134   1       SPI_RW(value);//–¥»Î“ª◊÷Ω⁄
 135   1       CSN=1;//
 136   1       return status;//∑µªÿ◊¥Ã¨
 137   1      }
 138          uchar SPI_R_byte(uchar reg)        //SPI∂¡“ª◊÷Ω⁄
 139          {
 140   1       uchar reg_value;
 141   1       CSN=0;//SPI∆¨—°
 142   1       SPI_RW(reg);//–¥»Îµÿ÷∑
 143   1       reg_value=SPI_RW(0);//∂¡»°ºƒ¥Ê∆˜µƒ÷µ
 144   1       CSN=1;
 145   1       return reg_value;//∑µªÿ∂¡»°µƒ÷µ
 146   1      }
 147          //SPI∂¡»°RXFIFOºƒ¥Ê∆˜ ˝æ›
 148          //reg:ºƒ¥Ê∆˜µÿ÷∑
 149          //Dat_Buffer:”√¿¥¥Ê∂¡»°µƒ ˝æ›
 150          //DLen: ˝æ›≥§∂»
 151          uchar SPI_R_DBuffer(uchar reg,uchar *Dat_Buffer,uchar Dlen)
 152          {
 153   1       uchar status,i;
 154   1       CSN=0;//SPI∆¨—°
 155   1       status=SPI_RW(reg);//–¥»Îºƒ¥Ê∆˜µÿ÷∑£¨Õ¨ ±◊¥Ã¨
 156   1       for(i=0;i<Dlen;i++)
 157   1       {
 158   2        Dat_Buffer[i]=SPI_RW(0);//¥Ê¥¢ ˝æ›
 159   2       }
 160   1       CSN=1;
 161   1       return status;
 162   1      }
 163          //SPIœÚTXFIFOºƒ¥Ê∆˜–¥»Î ˝æ›              reg:–¥»Îºƒ¥Ê∆˜µÿ÷∑
 164          //TX_Dat_Buffer:¥Ê∑≈–Ë“™∑¢ÀÕµƒ ˝æ›       Dlen: ˝æ›≥§∂»
 165          uchar SPI_W_DBuffer(uchar reg,uchar *TX_Dat_Buffer,uchar Dlen)   {
 166   1       uchar status,i;
 167   1       CSN=0;                                                 //SPI∆¨—°£¨∆Ù∂Ø ±–Ú
 168   1       status=SPI_RW(reg);
 169   1       for(i=0;i<Dlen;i++)
 170   1       {
 171   2        SPI_RW(TX_Dat_Buffer[i]);//∑¢ÀÕ ˝æ›
 172   2       }
 173   1       CSN=1;
 174   1       return status; 
 175   1      }
 176          void nRF24L01_Set_TX_Mode(uchar *TX_Data)          //…Ë÷√∑¢ÀÕƒ£ Ω
 177          {
C51 COMPILER V9.01   MAIN                                                                  11/30/2019 02:05:49 PAGE 4   

 178   1       CE=0;//¥˝ª˙£®–¥ºƒ¥Ê∆˜÷Æ«∞“ª∂®“™Ω¯»Î¥˝ª˙ƒ£ ΩªÚµÙµÁƒ£ Ω£©
 179   1       SPI_W_DBuffer(W_REGISTER+TX_ADDR,TX_Addr,TX_ADDR_WITDH);//–¥ºƒ¥Ê∆˜÷∏¡Ó+Ω” ’Ω⁄µ„µÿ÷∑+µÿ÷∑øÌ∂»
 180   1       SPI_W_DBuffer(W_REGISTER+RX_ADDR_P0,TX_Addr,TX_ADDR_WITDH);//Œ™¡ÀΩ” ’…Ë±∏”¶¥–≈∫≈£¨Ω” ’Õ®µ¿0µÿ÷∑”Î∑¢ÀÕµÿ÷
             -∑œ‡Õ¨
 181   1       SPI_W_DBuffer(W_TX_PLOAD,TX_Data,TX_DATA_WITDH);//–¥”––ß ˝æ›µÿ÷∑+”––ß ˝æ›+”––ß ˝æ›øÌ∂»
 182   1       SPI_W_Reg(W_REGISTER+EN_AA,0x01);//Ω” ’Õ®µ¿0◊‘∂Ø”¶¥
 183   1       SPI_W_Reg(W_REGISTER+EN_RX_ADDR,0x01);// πƒ‹Ω” ’Õ®µ¿0
 184   1       SPI_W_Reg(W_REGISTER+SETUP_RETR,0x0a);//◊‘∂Ø÷ÿ∑¢—” ±250US+86US£¨÷ÿ∑¢10¥Œ
 185   1       SPI_W_Reg(W_REGISTER+RF_CH,0);//2.4GHZ
 186   1       SPI_W_Reg(W_REGISTER+RF_SETUP,0x07);//1MbpsÀŸ¬ ,∑¢…‰π¶¬ :0DBM,µÕ‘Î…˘∑≈¥Û∆˜‘ˆ“Ê
 187   1       SPI_W_Reg(W_REGISTER+CONFIG,0x0e);//∑¢ÀÕƒ£ Ω,…œµÁ,16ŒªCRC–£—È,CRC πƒ‹
 188   1       CE=1;//∆Ù∂Ø∑¢…‰
 189   1       delayms(5);//CE∏ﬂµÁ∆Ω≥÷–¯ ±º‰◊Ó…Ÿ10US“‘…œ
 190   1      }
 191          uchar Check_Ack(void)       //ºÏ≤‚”¶¥–≈∫≈
 192          {
 193   1       sta=SPI_R_byte(R_REGISTER+STATUS);//∂¡»°ºƒ¥Ê◊¥Ã¨
 194   1       if(TX_DS||MAX_RT)//»Áπ˚TX_DSªÚMAX_RTŒ™1,‘Ú«Â≥˝÷–∂œ∫Õ«Â≥˝TX_FIFOºƒ¥Ê∆˜µƒ÷µ
 195   1       {
 196   2        SPI_W_Reg(W_REGISTER+STATUS,0xff);
 197   2        CSN=0;
 198   2        SPI_RW(FLUSH_TX);//»Áπ˚√ª”–’‚“ªæ‰÷ªƒ‹∑¢“ª¥Œ ˝æ›£¨¥Ûº““™◊¢“‚
 199   2        CSN=1;
 200   2        return 0;
 201   2       }
 202   1       else
 203   1        return 1;
 204   1      }
 205          
 206          void nRF24L01_Set_RX_Mode(void)
 207          {
 208   1       CE=0;                          //??
 209   1       SPI_W_DBuffer(W_REGISTER+TX_ADDR,TX_Addr,TX_ADDR_WITDH);
 210   1       SPI_W_DBuffer(W_REGISTER+RX_ADDR_P0,TX_Addr,TX_ADDR_WITDH);
 211   1       SPI_W_Reg(W_REGISTER+EN_AA,0x01);//auot ack
 212   1       SPI_W_Reg(W_REGISTER+EN_RX_ADDR,0x01);
 213   1       SPI_W_Reg(W_REGISTER+SETUP_RETR,0x0a);
 214   1       SPI_W_Reg(W_REGISTER+RX_PW_P0,RX_DATA_WITDH);
 215   1       SPI_W_Reg(W_REGISTER+RF_CH,0);
 216   1       SPI_W_Reg(W_REGISTER+RF_SETUP,0x07);//0db,lna
 217   1       SPI_W_Reg(W_REGISTER+CONFIG,0x0f);
 218   1       
 219   1       CE=1;
 220   1       _delay_ms(5);
 221   1      }
 222          
 223          uchar nRF24L01_RX_Data(void)     {
 224   1       sta=SPI_R_byte(R_REGISTER+STATUS);
 225   1       if(RX_DR)       {
 226   2        CE=0;
 227   2        SPI_R_DBuffer(R_RX_PLOAD,RX_Buffer,RX_DATA_WITDH);
 228   2        SPI_W_Reg(W_REGISTER+STATUS,0xff);
 229   2        CSN=0;
 230   2        SPI_RW(FLUSH_RX);
 231   2        CSN=1;
 232   2        return 1;
 233   2       }
 234   1       else     return 0;
 235   1      }
 236          
 237          u8 keyk1_4()   {
 238   1              if(k1==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
C51 COMPILER V9.01   MAIN                                                                  11/30/2019 02:05:49 PAGE 5   

 239   2                      _delay_ms(10);   //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 240   2                      if(k1==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 241   3                              led=~led;       return 1;  //led◊¥Ã¨»°∑¥
 242   3                      }
 243   2                      while(!k1);      //ºÏ≤‚∞¥º¸ «∑ÒÀ…ø™
 244   2              }       
 245   1              if(k2==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 246   2              _delay_ms(10);  //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 247   2              if(k2==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 248   3                      led1=~led1;     return 2;         //led◊¥Ã¨»°∑¥
 249   3              }
 250   2              while(!k3);      //ºÏ≤‚∞¥º¸ «∑ÒÀ…ø™
 251   2              }
 252   1              if(k3==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 253   2                      _delay_ms(10);   //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 254   2                      if(k3==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 255   3                              led2=~led2;     return 3;         //led◊¥Ã¨»°∑¥
 256   3              }
 257   2              while(!k4);      //ºÏ≤‚∞¥º¸ «∑ÒÀ…ø™
 258   2              }       
 259   1              if(k4==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 260   2                      _delay_ms(10);  //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 261   2                      if(k4==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 262   3                              led3=~led3;     return 4;         //led◊¥Ã¨»°∑¥
 263   3                      }
 264   2              }       return 0;                }
 265          
 266          
 267          /*******************************************************************************
 268          * ∫Ø ˝√˚         : Usart() interrupt 4
 269          * ∫Ø ˝π¶ƒ‹                : ¥Æø⁄Õ®–≈÷–∂œ∫Ø ˝
 270          *******************************************************************************/
 271          void Usart() interrupt 4                {   //¥Æ––ø⁄÷–∂œ
 272   1              RI = 0;                                         //«Â≥˝Ω” ’÷–∂œ±Í÷æŒª
 273   1              sbuf[sbufc]      = SBUF;        //≥ˆ»•Ω” ’µΩµƒ ˝æ›
 274   1               sbufc++; if (sbufc >  sbuflen)   sbufoverflow=1;
 275   1      //      SBUF=receiveData;                               //Ω´Ω” ’µΩµƒ ˝æ›∑≈»ÎµΩ∑¢ÀÕºƒ¥Ê∆˜
 276   1      //      while(!TI);                                              //µ»¥˝∑¢ÀÕ ˝æ›ÕÍ≥…
 277   1      //      TI=0;                                                   //«Â≥˝∑¢ÀÕÕÍ≥…±Í÷æŒª
 278   1      }
 279          void Timer0() interrupt 1       {        //time0 
 280   1              static u16 i;
 281   1              TH0=0XFC;       TL0=0X18;       //∏¯∂® ±∆˜∏≥≥ı÷µ£¨∂® ±1ms
 282   1              i++;
 283   1              if(i==1000)     {       i=0;    led=~led;       }                               //“ª√Î 
 284   1      }
 285          
 286          // ∫Ø ˝π¶ƒ‹                : Õ‚≤ø÷–∂œ0 ÷–∂œ∫Ø ˝
 287          void Int0() interrupt 0 {
 288   1              _delay_ms(10);
 289   1              if(k3==0)
 290   1              {
 291   2                      SetState=~SetState;
 292   2                      SetPlace=0;
 293   2                      Ds1302Init();   
 294   2              }
 295   1              led5 = ~led5;
 296   1      sbufsendstr("int0");
 297   1      }
 298          void disptime() {
 299   1                      if(SetState==0) { Ds1302ReadTime();     }       //œ‘ æ ±º‰
 300   1                      else    {
C51 COMPILER V9.01   MAIN                                                                  11/30/2019 02:05:49 PAGE 6   

 301   2                              if(keyk1_4() == 1) {            //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 302   3                                      SetPlace++;       _delay_us(1000);  sbufsend('B');
 303   3                                      if(SetPlace>=7) SetPlace=0;                                     
 304   3                              }
 305   2                              if(keyk1_4() == 2) {            //ºÏ≤‚∞¥º¸K2 «∑Ò∞¥œ¬
 306   3                                              TIME[SetPlace]++;
 307   3                                              if((TIME[SetPlace]&0x0f)>9)                                      //ªª≥…BCD¬Î°£
 308   3                                              {
 309   4                                                      TIME[SetPlace]=TIME[SetPlace]+6;
 310   4                                              }
 311   3                                              if((TIME[SetPlace]>=0x60)&&(SetPlace<2))                //∑÷√Î÷ªƒ‹µΩ59
 312   3                                              {
 313   4                                                      TIME[SetPlace]=0;
 314   4                                              }
 315   3                                              if((TIME[SetPlace]>=0x24)&&(SetPlace==2))               //–° ±÷ªƒ‹µΩ23
 316   3                                              {
 317   4                                                      TIME[SetPlace]=0;
 318   4                                              }
 319   3                                              if((TIME[SetPlace]>=0x32)&&(SetPlace==3))               //»’÷ªƒ‹µΩ31
 320   3                                              {
 321   4                                                      TIME[SetPlace]=0;       
 322   4                                              }
 323   3                                              if((TIME[SetPlace]>=0x13)&&(SetPlace==4))               //‘¬÷ªƒ‹µΩ12
 324   3                                              {
 325   4                                                      TIME[SetPlace]=0;
 326   4                                              }       
 327   3                                              if((TIME[SetPlace]>=0x7)&&(SetPlace==5)) {              //÷‹÷ªƒ‹µΩ7
 328   4                                                      TIME[SetPlace]=1;
 329   4                                              }               
 330   3                              }                                               
 331   2                      }
 332   1                      LcdDisplaytime();       
 333   1      }
 334          
 335          /*  π¶ƒ‹£∫’˚ ˝◊™ªªŒ™◊÷∑˚¥Æ
 336           * char s[] µƒ◊˜”√ «¥Ê¥¢’˚ ˝µƒ√ø“ªŒª  */
 337          
 338          char *itoa(int n) {
 339   1          int i = 0,isNegative = 0;
 340   1          if((isNegative = n) < 0) //»Áπ˚ «∏∫ ˝£¨œ»◊™Œ™’˝ ˝
 341   1          {
 342   2              n = -n;
 343   2          }
 344   1          do      //¥”∏˜Œªø™ º±‰Œ™◊÷∑˚£¨÷±µΩ◊Ó∏ﬂŒª£¨◊Ó∫Û”¶∏√∑¥◊™
 345   1          {
 346   2              itoap[i++] = n%10 + '0';
 347   2              n = n/10;
 348   2          }while(n > 0);
 349   1          if(isNegative < 0)   //»Áπ˚ «∏∫ ˝£¨≤π…œ∏∫∫≈
 350   1          {
 351   2              itoap[i++] = '-';
 352   2          }
 353   1          itoap[i] = '\0';    //◊Ó∫Ûº”…œ◊÷∑˚¥ÆΩ· ¯∑˚
 354   1          return itoap  ;   //reverse(s);
 355   1      }
 356          
 357          
 358          
 359          void UsartInit()         //œµÕ≥≥ı ºªØ
 360          {
 361   1              SCON=0X50;                      //…Ë÷√Œ™π§◊˜∑Ω Ω1
 362   1              TMOD=0X21;                      //…Ë÷√º∆ ˝∆˜π§◊˜∑Ω Ω2
C51 COMPILER V9.01   MAIN                                                                  11/30/2019 02:05:49 PAGE 7   

 363   1              PCON=0X80;                      //≤®Ãÿ¬ º”±∂
 364   1              TH1=0XF3;               TL1=0XF3;               //º∆ ˝∆˜≥ı º÷µ…Ë÷√£¨0XF3≤®Ãÿ¬  «4800µƒ   th1=0xfd:19200      
 365   1              ES=1;   EA=1;   //¥Úø™◊‹÷–∂œ            //¥Úø™Ω” ’÷–∂œ
 366   1              TR1=1;                                  //¥Úø™º∆ ˝∆˜    TMOD|=0X01;//—°‘ÒŒ™∂® ±∆˜0ƒ£ Ω£¨π§◊˜∑Ω Ω1£¨Ωˆ”√TR0¥Úø™∆Ù∂Ø°£
 367   1              TH0=0XFC;       TL0=0X18;       //∏¯∂® ±∆˜∏≥≥ı÷µ£¨∂® ±1ms
 368   1      //      ET0=1;          TR0=1;                  //¥Úø™∂® ±∆˜0÷–∂œ‘ –Ì   //¥Úø™∂® ±∆˜
 369   1      //      IT0=1;//Ã¯±‰—ÿ≥ˆ∑¢∑Ω Ω£®œ¬Ωµ—ÿ£©        //…Ë÷√INT0
 370   1      //      EX0=1;//¥Úø™INT0µƒ÷–∂œ‘ –Ì°£//  EA=1;//¥Úø™◊‹÷–∂œ       
 371   1      //       P0=0xff;        P1=0xff;        P2=0xff;        P3=0xff;
 372   1              
 373   1      }
 374          
 375          
 376          void main()        {
 377   1              UsartInit();  //        ¥Æø⁄≥ı ºªØ
 378   1         _delay_us(100);
 379   1              LcdInit();      //      Ds1302Init(); //        LcdDisplay1("Disp",2);LcdDisplay2("Yuanding",3);          //µ⁄“ª–– ‘⁄ x Œª÷√œ‘ æ
 380   1      //      for(i=0;i<16;i++)       {               _delay_ms(60)   ;               }               LcdInit();              //«Î∆¡ all ¡Ω––
 381   1      // int t16 ;    char str[5];
 382   1       //     LcdWriteCom(0x88);      LcdWriteData('C');                      //–¥µÿ÷∑ 80±Ì æ≥ı ºµÿ÷∑
 383   1      //      t16 =  Ds18b20ReadTemp();       //      itoa(t16);                sbufsendstr("1CDDDDCC2 "); 
 384   1       //   LcdDisplaytemp(Ds18b20ReadTemp());
 385   1               _delay_us(100);
 386   1               nRF24L01_Init();
 387   1          while(1)    {          //
 388   2               sbufsend('A'); 
 389   2                nRF24L01_Set_RX_Mode();
 390   2                _delay_ms(100);
 391   2                if(nRF24L01_RX_Data())          {
 392   3                 led=0;                                                       //?????????
 393   3                       sbufsendstr(" led0 "); 
 394   3                }
 395   2                else                  //????
 396   2                 led=1;        sbufsendstr(" led1 ");   // ’µΩ ˝æ›
 397   2               }
 398   1      
 399   1       while(1)   {
 400   2        for(i=0;i<TX_DATA_WITDH-1;i++)                //∑¢ÀÕ7¥Œ ˝æ›
 401   2        {
 402   3         nRF24L01_Set_TX_Mode(&TX_Buffer[i]);//∑¢ÀÕ ˝æ›
 403   3         while(Check_Ack());          //µ»¥˝∑¢ÀÕÕÍ≥…
 404   3          LED=~LED;
 405   3        }
 406   2       }
 407   1      
 408   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1444    ----
   CONSTANT SIZE    =     37    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21      33
   IDATA SIZE       =     57    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
