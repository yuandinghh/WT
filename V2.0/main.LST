C51 COMPILER V9.01   MAIN                                                                  11/27/2019 13:51:27 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: F:\mdk4\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**************************************************************************************
   2          *                             ¥Æø⁄Õ®–≈ µ—È                                                                                                *
   3           µœ÷œ÷œÛ£∫œ¬‘ÿ≥Ã–Ú∫Û¥Úø™¥Æø⁄µ˜ ‘÷˙ ÷£¨Ω´≤®Ãÿ¬ …Ë÷√Œ™4800£¨—°‘Ò∑¢ÀÕµƒ ˝æ›æÕø…“‘œ‘ æ
   4                                  ‘⁄¥Æø⁄÷˙ ÷…œ°£
   5          ◊¢“‚ ¬œÓ£∫Œﬁ°£                                                                                                                                                            
   6          ***************************************************************************************/
   7          //#include <REGX52.H>
   8          #include "lcd.h"
   9          #include "reg51.h"                       //¥ÀŒƒº˛÷–∂®“Â¡Àµ•∆¨ª˙µƒ“ª–©Ãÿ ‚π¶ƒ‹ºƒ¥Ê∆˜
  10          #include "RF2401.h"     
  11          #include <intrins.h>
  12          
  13          uchar  sta,i;    //  ◊¥Ã¨±‰¡ø
  14          #define RX_DR  (sta & 0x40)  // Ω” ’≥…π¶÷–∂œ±Í÷æ
  15          #define TX_DS  (sta & 0x20)  // ∑¢…‰≥…π¶÷–∂œ±Í÷æ
  16          #define MAX_RT (sta & 0x10)  // ÷ÿ∑¢“Á≥ˆ÷–∂œ±Í÷æ
  17          #define sbuflen  50   //¥Æ––Ω” ‹≥§∂»
  18          
  19          bit sbufoverflow = 0 ;    //keil∂®“ÂŒª±‰¡ø
  20          u8 sbuf[sbuflen], sbufc=0;
  21          
  22          sbit CE=P1^5;
  23          sbit IRQ=P1^0;
  24          sbit CSN=P1^4;
  25          sbit MOSI=P1^2;
  26          sbit MISO=P1^1;
  27          sbit SCK=P1^3;
  28          
  29          sbit led=P2^0;  sbit LED=P2^0; //sbit LED=P0^0;
  30          sbit led1=P2^1; sbit led2=P2^2;  sbit led3=P2^3;
  31          sbit k1 = P3^1 ;    sbit  k2=  P3^0; sbit  k3 = P3^2; sbit  k4 = P3^3;  //key
  32          uchar code TX_Addr[]={0x34,0x43,0x10,0x10,0x01};
  33          uchar code TX_Buffer[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  34          uchar RX_Buffer[RX_DATA_WITDH];
  35          
  36          void _delay_us(uint x)     {
  37   1       uint i,j;
  38   1       for (j=0;j<x;j++)
  39   1        for (i=0;i<12;i++);
  40   1      }
  41          void _delay_ms(uint x)
  42          {
  43   1       uint i,j;
  44   1       for (j=0;j<x;j++)
  45   1        for (i=0;i<120;i++);
  46   1      }
  47          //nRF24L01≥ı ºªØ
  48          void nRF24L01_Init(void)
  49          {
  50   1       CE=0;//¥˝ª˙ƒ£ Ω¢Ò
  51   1       CSN=1;
  52   1       SCK=0;
  53   1       IRQ=1;
  54   1      }
  55          //SPI ±–Ú∫Ø ˝
C51 COMPILER V9.01   MAIN                                                                  11/27/2019 13:51:27 PAGE 2   

  56          uchar SPI_RW(uchar byte)
  57          {
  58   1       uchar i;
  59   1       for(i=0;i<8;i++)//“ª◊÷Ω⁄8Œª—≠ª∑8¥Œ–¥»Î
  60   1       {
  61   2        if(byte&0x80)//»Áπ˚ ˝æ›◊Ó∏ﬂŒª «1
  62   2         MOSI=1;//œÚNRF24L01–¥1
  63   2        else //∑Ò‘Ú–¥0
  64   2         MOSI=0;
  65   2        byte<<=1;//µÕ“ªŒª“∆µΩ◊Ó∏ﬂŒª
  66   2        SCK=1;//SCK¿≠∏ﬂ£¨–¥»Î“ªŒª ˝æ›£¨Õ¨ ±∂¡»°“ªŒª ˝æ›
  67   2        if(MISO)
  68   2         byte|=0x01;
  69   2        SCK=0;//SCK¿≠µÕ
  70   2       }
  71   1       return byte;//∑µªÿ∂¡»°“ª◊÷Ω⁄
  72   1      }
  73          //SPI–¥ºƒ¥Ê∆˜“ª◊÷Ω⁄∫Ø ˝
  74          //reg:ºƒ¥Ê∆˜µÿ÷∑
  75          //value:“ª◊÷Ω⁄£®÷µ£©
  76          uchar SPI_W_Reg(uchar reg,uchar value)
  77          {
  78   1       uchar status;//∑µªÿ◊¥Ã¨
  79   1       CSN=0;//SPI∆¨—°
  80   1       status=SPI_RW(reg);//–¥»Îºƒ¥Ê∆˜µÿ÷∑£¨Õ¨ ±∂¡»°◊¥Ã¨
  81   1       SPI_RW(value);//–¥»Î“ª◊÷Ω⁄
  82   1       CSN=1;//
  83   1       return status;//∑µªÿ◊¥Ã¨
  84   1      }
  85          uchar SPI_R_byte(uchar reg)        //SPI∂¡“ª◊÷Ω⁄
  86          {
  87   1       uchar reg_value;
  88   1       CSN=0;//SPI∆¨—°
  89   1       SPI_RW(reg);//–¥»Îµÿ÷∑
  90   1       reg_value=SPI_RW(0);//∂¡»°ºƒ¥Ê∆˜µƒ÷µ
  91   1       CSN=1;
  92   1       return reg_value;//∑µªÿ∂¡»°µƒ÷µ
  93   1      }
  94          //SPI∂¡»°RXFIFOºƒ¥Ê∆˜ ˝æ›
  95          //reg:ºƒ¥Ê∆˜µÿ÷∑
  96          //Dat_Buffer:”√¿¥¥Ê∂¡»°µƒ ˝æ›
  97          //DLen: ˝æ›≥§∂»
  98          uchar SPI_R_DBuffer(uchar reg,uchar *Dat_Buffer,uchar Dlen)
  99          {
 100   1       uchar status,i;
 101   1       CSN=0;//SPI∆¨—°
 102   1       status=SPI_RW(reg);//–¥»Îºƒ¥Ê∆˜µÿ÷∑£¨Õ¨ ±◊¥Ã¨
 103   1       for(i=0;i<Dlen;i++)
 104   1       {
 105   2        Dat_Buffer[i]=SPI_RW(0);//¥Ê¥¢ ˝æ›
 106   2       }
 107   1       CSN=1;
 108   1       return status;
 109   1      }
 110          //SPIœÚTXFIFOºƒ¥Ê∆˜–¥»Î ˝æ›
 111          //reg:–¥»Îºƒ¥Ê∆˜µÿ÷∑
 112          //TX_Dat_Buffer:¥Ê∑≈–Ë“™∑¢ÀÕµƒ ˝æ›
 113          //Dlen: ˝æ›≥§∂»
 114          uchar SPI_W_DBuffer(uchar reg,uchar *TX_Dat_Buffer,uchar Dlen)
 115          {
 116   1       uchar status,i;
 117   1       CSN=0;//SPI∆¨—°£¨∆Ù∂Ø ±–Ú
C51 COMPILER V9.01   MAIN                                                                  11/27/2019 13:51:27 PAGE 3   

 118   1       status=SPI_RW(reg);
 119   1       for(i=0;i<Dlen;i++)
 120   1       {
 121   2        SPI_RW(TX_Dat_Buffer[i]);//∑¢ÀÕ ˝æ›
 122   2       }
 123   1       CSN=1;
 124   1       return status; 
 125   1      }
 126          void nRF24L01_Set_TX_Mode(uchar *TX_Data)          //…Ë÷√∑¢ÀÕƒ£ Ω
 127          {
 128   1       CE=0;//¥˝ª˙£®–¥ºƒ¥Ê∆˜÷Æ«∞“ª∂®“™Ω¯»Î¥˝ª˙ƒ£ ΩªÚµÙµÁƒ£ Ω£©
 129   1       SPI_W_DBuffer(W_REGISTER+TX_ADDR,TX_Addr,TX_ADDR_WITDH);//–¥ºƒ¥Ê∆˜÷∏¡Ó+Ω” ’Ω⁄µ„µÿ÷∑+µÿ÷∑øÌ∂»
 130   1       SPI_W_DBuffer(W_REGISTER+RX_ADDR_P0,TX_Addr,TX_ADDR_WITDH);//Œ™¡ÀΩ” ’…Ë±∏”¶¥–≈∫≈£¨Ω” ’Õ®µ¿0µÿ÷∑”Î∑¢ÀÕµÿ÷
             -∑œ‡Õ¨
 131   1       SPI_W_DBuffer(W_TX_PLOAD,TX_Data,TX_DATA_WITDH);//–¥”––ß ˝æ›µÿ÷∑+”––ß ˝æ›+”––ß ˝æ›øÌ∂»
 132   1       SPI_W_Reg(W_REGISTER+EN_AA,0x01);//Ω” ’Õ®µ¿0◊‘∂Ø”¶¥
 133   1       SPI_W_Reg(W_REGISTER+EN_RX_ADDR,0x01);// πƒ‹Ω” ’Õ®µ¿0
 134   1       SPI_W_Reg(W_REGISTER+SETUP_RETR,0x0a);//◊‘∂Ø÷ÿ∑¢—” ±250US+86US£¨÷ÿ∑¢10¥Œ
 135   1       SPI_W_Reg(W_REGISTER+RF_CH,0);//2.4GHZ
 136   1       SPI_W_Reg(W_REGISTER+RF_SETUP,0x07);//1MbpsÀŸ¬ ,∑¢…‰π¶¬ :0DBM,µÕ‘Î…˘∑≈¥Û∆˜‘ˆ“Ê
 137   1       SPI_W_Reg(W_REGISTER+CONFIG,0x0e);//∑¢ÀÕƒ£ Ω,…œµÁ,16ŒªCRC–£—È,CRC πƒ‹
 138   1       CE=1;//∆Ù∂Ø∑¢…‰
 139   1       _delay_ms(5);//CE∏ﬂµÁ∆Ω≥÷–¯ ±º‰◊Ó…Ÿ10US“‘…œ
 140   1      }
 141          uchar Check_Ack(void)       //ºÏ≤‚”¶¥–≈∫≈
 142          {
 143   1       sta=SPI_R_byte(R_REGISTER+STATUS);//∂¡»°ºƒ¥Ê◊¥Ã¨
 144   1       if(TX_DS||MAX_RT)//»Áπ˚TX_DSªÚMAX_RTŒ™1,‘Ú«Â≥˝÷–∂œ∫Õ«Â≥˝TX_FIFOºƒ¥Ê∆˜µƒ÷µ
 145   1       {
 146   2        SPI_W_Reg(W_REGISTER+STATUS,0xff);
 147   2        CSN=0;
 148   2        SPI_RW(FLUSH_TX);//»Áπ˚√ª”–’‚“ªæ‰÷ªƒ‹∑¢“ª¥Œ ˝æ›£¨¥Ûº““™◊¢“‚
 149   2        CSN=1;
 150   2        return 0;
 151   2       }
 152   1       else
 153   1        return 1;
 154   1      }
 155          
 156          void nRF24L01_Set_RX_Mode(void)
 157          {
 158   1       CE=0;//??
 159   1       SPI_W_DBuffer(W_REGISTER+TX_ADDR,TX_Addr,TX_ADDR_WITDH);
 160   1       SPI_W_DBuffer(W_REGISTER+RX_ADDR_P0,TX_Addr,TX_ADDR_WITDH);
 161   1       SPI_W_Reg(W_REGISTER+EN_AA,0x01);//auot ack
 162   1       SPI_W_Reg(W_REGISTER+EN_RX_ADDR,0x01);
 163   1       SPI_W_Reg(W_REGISTER+SETUP_RETR,0x0a);
 164   1       SPI_W_Reg(W_REGISTER+RX_PW_P0,RX_DATA_WITDH);
 165   1       SPI_W_Reg(W_REGISTER+RF_CH,0);
 166   1       SPI_W_Reg(W_REGISTER+RF_SETUP,0x07);//0db,lna
 167   1       SPI_W_Reg(W_REGISTER+CONFIG,0x0f);
 168   1       
 169   1       CE=1;
 170   1       _delay_ms(5);
 171   1      }
 172          
 173          uchar nRF24L01_RX_Data(void)     {
 174   1       sta=SPI_R_byte(R_REGISTER+STATUS);
 175   1       if(RX_DR)       {
 176   2        CE=0;
 177   2        SPI_R_DBuffer(R_RX_PLOAD,RX_Buffer,RX_DATA_WITDH);
 178   2        SPI_W_Reg(W_REGISTER+STATUS,0xff);
C51 COMPILER V9.01   MAIN                                                                  11/27/2019 13:51:27 PAGE 4   

 179   2        CSN=0;
 180   2        SPI_RW(FLUSH_RX);
 181   2        CSN=1;
 182   2        return 1;
 183   2       }
 184   1       else     return 0;
 185   1      }
 186          
 187          void UsartInit()         //œµÕ≥≥ı ºªØ
 188          {
 189   1              SCON=0X50;                      //…Ë÷√Œ™π§◊˜∑Ω Ω1
 190   1              TMOD=0X21;                      //…Ë÷√º∆ ˝∆˜π§◊˜∑Ω Ω2
 191   1              PCON=0X80;                      //≤®Ãÿ¬ º”±∂
 192   1              TH1=0XF3;               TL1=0XF3;               //º∆ ˝∆˜≥ı º÷µ…Ë÷√£¨0XF3≤®Ãÿ¬  «4800µƒ   th1=0xfd:19200      
 193   1              ES=1;   EA=1;   //¥Úø™◊‹÷–∂œ            //¥Úø™Ω” ’÷–∂œ
 194   1              TR1=1;                                  //¥Úø™º∆ ˝∆˜    TMOD|=0X01;//—°‘ÒŒ™∂® ±∆˜0ƒ£ Ω£¨π§◊˜∑Ω Ω1£¨Ωˆ”√TR0¥Úø™∆Ù∂Ø°£
 195   1              TH0=0XFC;       TL0=0X18;       //∏¯∂® ±∆˜∏≥≥ı÷µ£¨∂® ±1ms
 196   1              ET0=1;          TR0=1;                  //¥Úø™∂® ±∆˜0÷–∂œ‘ –Ì   //¥Úø™∂® ±∆˜
 197   1      //       P0=0xff;        P1=0xff;        P2=0xff;        P3=0xff;
 198   1                      
 199   1      }
 200          
 201          void delay1u(u16 i)
 202          {
 203   1              while(i--);     
 204   1      }
 205          
 206          u8 keyk1_4()
 207          {
 208   1              if(k1==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 209   2                      delay1u(1000);   //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 210   2                      if(k1==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 211   3                              led=~led;       return 1;  //led◊¥Ã¨»°∑¥
 212   3                      }
 213   2                      while(!k1);      //ºÏ≤‚∞¥º¸ «∑ÒÀ…ø™
 214   2              }       
 215   1              if(k2==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 216   2              delay1u(1000);   //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 217   2              if(k2==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 218   3                      led1=~led1;     return 2;         //led◊¥Ã¨»°∑¥
 219   3              }
 220   2              while(!k1);      //ºÏ≤‚∞¥º¸ «∑ÒÀ…ø™
 221   2              }
 222   1              if(k3==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 223   2                      delay1u(1000);   //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 224   2                      if(k3==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 225   3                              led2=~led2;     return 3;         //led◊¥Ã¨»°∑¥
 226   3              }
 227   2              while(!k1);      //ºÏ≤‚∞¥º¸ «∑ÒÀ…ø™
 228   2              }       
 229   1              if(k4==0) {               //ºÏ≤‚∞¥º¸K1 «∑Ò∞¥œ¬
 230   2                      delay1u(1000);   //œ˚≥˝∂∂∂Ø “ª∞„¥Û‘º10ms
 231   2                      if(k4==0) {      //‘Ÿ¥Œ≈–∂œ∞¥º¸ «∑Ò∞¥œ¬
 232   3                              led3=~led3;     return 4;         //led◊¥Ã¨»°∑¥
 233   3              }
 234   2              while(!k1);      //ºÏ≤‚∞¥º¸ «∑ÒÀ…ø™
 235   2              }                                                                                       
 236   1      }
 237          void main()        {
 238   1      u8 Disp[]=" Pechin Science ";   
 239   1              UsartInit();  //        ¥Æø⁄≥ı ºªØ
 240   1               _delay_us(100);
C51 COMPILER V9.01   MAIN                                                                  11/27/2019 13:51:27 PAGE 5   

 241   1                LcdInit();
 242   1              for(i=0;i<16;i++)
 243   1              {
 244   2                      LcdWriteData(Disp[i]);  
 245   2              }
 246   1                 while(1)     {
 247   2                              keyk1_4();      
 248   2                 } ;
 249   1               _delay_us(1000);
 250   1               nRF24L01_Init();
 251   1               while(1)
 252   1               {
 253   2                nRF24L01_Set_RX_Mode();
 254   2                _delay_ms(100);
 255   2                if(nRF24L01_RX_Data())
 256   2                {
 257   3                 LED=0;//?????????
 258   3                }
 259   2                else//????
 260   2                 LED=1;
 261   2               }
 262   1       while(1)
 263   1       {
 264   2        for(i=0;i<TX_DATA_WITDH-1;i++)                //∑¢ÀÕ7¥Œ ˝æ›
 265   2        {
 266   3         nRF24L01_Set_TX_Mode(&TX_Buffer[i]);//∑¢ÀÕ ˝æ›
 267   3         while(Check_Ack());          //µ»¥˝∑¢ÀÕÕÍ≥…
 268   3          LED=~LED;
 269   3        }
 270   2       }
 271   1      
 272   1      }
 273          
 274          /*******************************************************************************
 275          * ∫Ø ˝√˚         : Usart() interrupt 4
 276          * ∫Ø ˝π¶ƒ‹                : ¥Æø⁄Õ®–≈÷–∂œ∫Ø ˝
 277          *******************************************************************************/
 278          void Usart() interrupt 4
 279          {
 280   1              u8 receiveData;         receiveData=SBUF;                       //≥ˆ»•Ω” ’µΩµƒ ˝æ›
 281   1              RI = 0;                                         //«Â≥˝Ω” ’÷–∂œ±Í÷æŒª
 282   1              sbuf[sbufc]      = receiveData;
 283   1               sbufc++; if (sbufc >  sbuflen)   sbufoverflow=1;
 284   1              SBUF=receiveData;                               //Ω´Ω” ’µΩµƒ ˝æ›∑≈»ÎµΩ∑¢ÀÕºƒ¥Ê∆˜
 285   1              while(!TI);                                              //µ»¥˝∑¢ÀÕ ˝æ›ÕÍ≥…
 286   1              TI=0;                                                   //«Â≥˝∑¢ÀÕÕÍ≥…±Í÷æŒª
 287   1      }
 288          
 289          void Timer0() interrupt 1
 290          {
 291   1              static u16 i;
 292   1              TH0=0XFC;       TL0=0X18;       //∏¯∂® ±∆˜∏≥≥ı÷µ£¨∂® ±1ms
 293   1              i++;
 294   1              if(i==1000)     {       i=0;    led=~led;       }                               //“ª√Î 
 295   1      }
*** WARNING C291 IN LINE 236 OF MAIN.C: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    736    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.01   MAIN                                                                  11/27/2019 13:51:27 PAGE 6   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     63      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
