#include "LCD12864.h"

//液晶数字符号图片,宽度x高度=16x32
//PCtoLCD2002取模:顺向,逐行式
u8 num1632[11][64]={
{//图片数字0
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x3E,0x78,0x3E,0x78,0x5E,0x78,0x5E,0x78,0x9E,0x78,0x9E,
0x79,0x1E,0x79,0x1E,0x7A,0x1E,0x7A,0x1E,0x7C,0x1E,0x7C,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00,},

{//图片数字1
0x00,0x00,0x00,0x38,0x00,0x78,0x00,0xF8,0x01,0xF8,0x01,0xF8,0x00,0x78,0x00,0x78,
0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,
0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,
0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x00},

{//图片数字2
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x3E,0x00,0x7E,0x00,0xFC,0x01,0xF8,
0x03,0xF0,0x07,0xE0,0x0F,0xC0,0x1F,0x80,0x3F,0x00,0x7E,0x00,0x7C,0x00,0x78,0x00,
0x78,0x00,0x78,0x00,0x78,0x1E,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x00,0x00},

{//图片数字3
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x00,0x1E,0x00,0x1E,0x00,0x3E,0x0F,0xFC,0x0F,0xF8,
0x0F,0xF8,0x0F,0xFC,0x00,0x3E,0x00,0x1E,0x00,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},

{//图片数字4
0x00,0x00,0x00,0x1C,0x00,0x3C,0x00,0x7C,0x00,0x7C,0x00,0xFC,0x01,0xFC,0x01,0xFC,
0x03,0xFC,0x07,0xBC,0x07,0xBC,0x0F,0x3C,0x0F,0x3C,0x1E,0x3C,0x1E,0x3C,0x3C,0x3C,
0x3C,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,
0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x00},
//图片数字5
0x00,0x00,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x78,0x00,0x78,0x00,0x78,0x00,
0x78,0x00,0x78,0x00,0x7B,0xF0,0x7F,0xF8,0x7F,0xFC,0x7F,0xFE,0x7E,0x3E,0x7C,0x1E,
0x7C,0x1E,0x00,0x1E,0x00,0x1E,0x00,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00,

{//图片数字6
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x00,0x78,0x00,0x78,0x00,0x7B,0xF0,0x7F,0xF8,0x7F,0xFC,0x7F,0xFE,
0x7C,0x3E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},

{//图片数字7
0x00,0x00,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x78,0x1E,0x00,0x1E,0x00,0x3C,
0x00,0x3C,0x00,0x78,0x00,0x78,0x00,0xF0,0x00,0xF0,0x01,0xE0,0x01,0xE0,0x03,0xC0,
0x03,0xC0,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,
0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x00,0x00},

{//图片数字8
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x3F,0xFC,0x1F,0xF8,0x1F,0xF8,
0x3F,0xFC,0x7C,0x3E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},

{//图片数字9
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x7C,0x3E,
0x7F,0xFE,0x3F,0xFE,0x1F,0xFE,0x0F,0xDE,0x00,0x1E,0x00,0x1E,0x00,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},
	
{// 图片":"	10
//6X6方点
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x07,0xE0,
0x07,0xE0,0x07,0xE0,0x07,0xE0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x07,0xE0,0x07,0xE0,0x07,0xE0,
0x07,0xE0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

};

//16x16图标
//PCtoLCD2002取模:顺向,逐行式
u8 bmp1616[3][32]=
{

//"℃"	  tt=0
{
0x00,0x00,0x30,0x00,0x48,0x00,0x49,0xC0,
0x33,0xE8,0x06,0x38,0x0C,0x18,0x0C,0x08,
0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,
0x06,0x08,0x03,0x10,0x01,0xE0,0x00,0x00
},     

//温度计图标
{
0x00,0x00,0x01,0x80,0x02,0x40,0x02,0xC0,
0x02,0x40,0x02,0xC0,0x02,0x40,0x02,0xC0,
0x02,0x40,0x03,0xC0,0x07,0xE0,0x0F,0xF0,
0x0F,0xF0,0x07,0xE0,0x03,0xC0,0x00,0x00
},

//负温度图标
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
}

};

void LCD12864_init(void)
{ 
    RCC->APB2ENR |= 1<<3;     //初始化PB口时钟
	RCC->APB2ENR |= 1<<4;     //初始化PC口时钟
	RCC->APB2ENR |= 1<<8;     //初始化PG口时钟

	GPIOB->CRL &= 0xfff00fff; //清除PB3 PB4先前的配置
	GPIOB->CRL |= 0x00033000; //PB3 PB4推挽输出
	GPIOB->ODR |= 3<<3;       //输出高电平

	GPIOG->CRH &= 0x000fffff; //清除PG13 PG14 PG15先前的配置
	GPIOG->CRH |= 0x33300000; //PG13 PG14 PG15推挽输出
	GPIOG->ODR |= 7<<13;	  //输出高电平

	GPIOC->CRL &= 0x00000000; //清除PC0-PC7先前的配置
	GPIOC->CRL |= 0x33333333; //PC0-PC7推挽输出
	GPIOC->ODR |= 255<<0;	  //输出高电平

	PSB = 1;                  //并口方式  
    write_com(0x30);          //基本指令操作
    delay_ms(5);
    write_com(0x0C);          //显示开，关光标
    delay_ms(5);
    write_com(0x01);          //清除LCD的显示内容
    delay_ms(5);
}

void chk_busy()	////检查忙位
{
	RS=0; RW=1; EN=1;
	DataPort(0xff);
	GPIOC->CRL &= 0x0fffffff; //清除PC7先前的设置
	GPIOC->CRL |= 0x80000000; //PC7设置成输入(默认下拉)
	GPIOC->ODR |= 0x10000000;       //PC7上拉
	while(PCin(7)==1);
	//delay_ms(2);
	//while((Lcd_Bus&0x80)==0x80);
	GPIOC->CRL &= 0x00000000; //清除PC0-PC7先前的配置
	GPIOC->CRL |= 0x33333333; //PC0-PC7推挽输出
	GPIOC->ODR |= 0x11111111; //输出高电平
	DataPort(0xff);

	EN=0;
}

void write_com(u8 cmdcode) //写指令到LCD
{
	chk_busy();
	RS=0; RW=0; EN=1;
	DataPort(cmdcode);
	EN=0;
}

void write_data(u8 Dispdata)	//写数据到LCD
{	 
	chk_busy();
	RS=1; RW=0; EN=1;
	DataPort(Dispdata);
	EN=0;
}

void lcm_w_word(u8 *s) //向LCM发送一个字符串,长度64字符之内
{
	while(*s>0) { write_data(*s); s++; }  //应用：lcm_w_word("您好！");
}

void lcm_w_test(u8 i,u8 word) //写指令或数据（被调用层）
{
	if(i == 0) write_com(word);//写指令（0，指令）
	else	   write_data(word);//写数据（1，数据）
}

void lcm_clr(void) //清屏函数
{	
	lcm_w_test(0,0x01);	
}

void lcm_clr2(void)	//清屏上面3行（用空格填满要清显示的地方，因为液晶屏是静态显示的，所以这办法常用）
{
	lcm_w_test(0,0x80);//第一行
	lcm_w_word("                ");//标尺("1234567812345678"应该能够显示满一行)
	lcm_w_test(0,0x90);//第二行
	lcm_w_word("                ");//标尺("1234567812345678"应该能够显示满一行)
	lcm_w_test(0,0x88);//第一行
	lcm_w_word("                ");//标尺("1234567812345678"应该能够显示满一行)
}

//使用绘图的方法让一个16*16的汉字符反白
//形式参数:u8 x,u8 y,u8 wide,u8 bkcor
//行参说明:坐标水平位置,坐标垂直位置,反白行数,要反白还是清除(1:反白,0:清除)   
void write1616GDRAM(u8 x,u8 y,u8 sign,u8 *bmp)	
{ 
	u8 i,j,basex;
	write_com(0x36);      //扩展指令，绘图模式命令，开显示也可以绘.(关图片显示0x34)
	if(y==1||y==2)	  //第一第二行
	{
		basex=0x80;	   //上半屏
		y=(y-1)*16;	  //垂直位址从0X80开始.
	}
	if(y==3||y==4)	//第三第四行
	{
		basex=0x88;	 //下半屏
		y=(y-3)*16;	 //垂直位址都是从0X80开始的，不管上下半屏。
	}
	for(i=0;i<16;i++)	//
	{															
		write_com(0x80+y+i);  //写入垂直位址。
		write_com(basex+x-1); //再写入水平位址(上半屏第一字为0X80，……第七字为0X87)
							   //下半屏第一字为0X88，……第七字为0X8F；
		for(j=0;j<2;j++)   //再写入两个8位元的数据,AC会自动增一，接着写数据
		{
			if(sign==1)  
				write_data(~(*bmp++));
			else  
				write_data(*bmp++);
		}
	}	
	write_com(0x36);  //写完数据，开图片显示     
}

//函数功能:显示16X16图形,适用于st7920型液晶
//形式参数:u8 x,u8 y,u8 *bmp
//行参说明:横坐标X列，纵坐标Y行，sign=1反白、=0不反，tt是要显示的图形bmp1616中的第几个 
void set1616pic(u8 x,u8 y,u8 sign,u8 tt) 
{
	u8 (*pp)[32];	 //定义指针
	pp=bmp1616;	  //二维数组首地址给指针，故指针指向下一个数组地址应为加64
	write1616GDRAM(x,y,sign,pp[tt]); //写入小时的十位	  
}

//函数功能:显示16X32图形,适用于st7920型液晶
//形式参数:u8 x,u8 y,u8 *bmp
//行参说明:横坐标X列，纵坐标Y行，要显示的图形BMP          
void write1632GDRAM(u8 x,u8 y,u8 *bmp)	
{ 
	u8 i,j,basex,basey;
	switch(y)	 //由y纵坐标定是上半屏还是下半屏
	{
	  case 1: basex=0x80; break;  //上半屏
	  case 2: basex=0x80; break;  //先上半屏，下面再下半屏。
	  case 3: basex=0x88; break;  //下半屏
	  default:   return;   //别的则返回
	}
	basey=basex+x-1;
	write_com(0x36);  
	if(y==1||y==3)	//如为第一第三行，则直接是在同一半屏，直接绘完32行点陈数据。
	{
		  for(i=0;i<32;i++)	 //写入32行点阵
		  {														
			    write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80
			    write_com(basey);     //再写入水平位址(选上下半屏)
			    for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
			    	write_data(*bmp++);   
		  }	 
	}
	if(y==2)  //从第二行开始则画图将上下半屏都有，所以先画完上半屏16行，再画下半屏16行。
	{					
		  for(i=0;i<16;i++)	 //写入上半屏16行点阵
		  {														
			    write_com(0x90+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80，第二行为0X90。
			    write_com(basey);    //(选上半屏)再写入水平位址
			    for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
			    	write_data(*bmp++);   
		  }
		  for(i=0;i<16;i++)	 //写入下半屏16行点阵
		  {														
			    write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80
			    write_com(basey+8);   //(选下半屏)再写入水平位址
			    for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
			    	write_data(*bmp++);   
		  }	 
	}
	write_com(0x36);  //写完数据，开图片显示     
}
        
//函数名称: init_12864_GDRAM(void)
//功能描述: 在程写GDRAM时序初始化12864 
void init_12864_GDRAM(void)	 
{
	write_com(0x30);     //基本指令操作(扩充指令操作为:0x34)
	write_com(0x0C);     //整体显示ON，游标OFF，游标位置OFF
	write_com(0x06);  	 //光标右移,DDRAM位址计数器(AC)加1,不整屏移动
	lcm_clr();           //清屏 (清DDRAM)
}

//函数名称:Clean_12864_GDRAM(void)						
//函数功能:清屏函数
//使用说明:GDRAM填满0
void Clean_12864_GDRAM(void)
{
    u8 x,y;
    write_com(0x36);
    init_12864_GDRAM();		//设置扩展指令集，按手册说明，仅设置了绘图位，
    write_com(0x36);	//需要两次，本次设置扩展指令集。
    for (y=0;y<32;y++)
    {
        write_com(0x80+y);  //设置y=1000+00xx，y+1则往下一行
        write_com(0x80);	//设置x=1000 0000
        for (x=0;x<16;x++)
        {
            write_data(0x00);   //高字节数据
            write_data(0x00);	//低字节数据
        }
    }
}
